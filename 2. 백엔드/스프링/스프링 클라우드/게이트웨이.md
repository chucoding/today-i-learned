# Spring Cloud Gateway
프록시 역할 (시스템의 내부 구조는 숨기고 외부의 요청에 대해서 적절한 형태로 가공해서 응답할 수 있음)

※ boot 2.4버전 이전에는 Zuul이라는 게이트웨이 서비스를 사용하고 있었지만 비동기 처리가 안되는 문제가 있어서 Spring Cloud Gateway가 등장. 최신 Zuul 버전은 비동기를 지원하지만 그래도 여전히 다른 Spring 라이브러리와 호환되지 않는 문제가 있어서 대부분 Spring Cloud Gateway를 사용

### 기능
- 인증 및 권한 부여
- 서비스 디스커버리
- 응답 캐싱 정보 저장 가능
- 정책, 회로차단기(써킷 브레이킹) 및 QoS 다시 시도
- 속도 제한
- 부하 분산
- 일괄 로깅(ELK 안써도됨), 추적, 상관 관계
- 헤더, 쿼리 문자열 및 청구 변환
- 외부 IP 허용, 차단

### 사용방법
application.yml
```yml
spring:
  application:
    name: apigateway-service
  cloud:
    gateway:
      routes:
        - id: first-service
          uri: http://localhost:8081/
          predicates:
            - Path=/first-service/**
        - id: second-service
          uri: http://localhost:8082/
          predicates:
            - Path=/second-service/**
```

❗ 인텔리제이에서 gateway 추가하는 경우 spring-cloud-starter-gateway-mvc로 받아지므로 주의 (mvn는 netty가 아닌 톰캣으로 실행이 된다.)


### 필터
```java
@Configuration
public class FilterConfig {
    @Bean
    public RouteLocator gatewayRoutes(RouteLocatorBuilder builder) {
        return builder.routes()
                .route(r -> r.path("/first-service/**")
                        .filters(f -> f.addRequestHeader("first-request", "first-request-header")
                                .addResponseHeader("first-response", "first-response-header"))
                        .uri("http://localhost:8081")) // .route는 체이닝 가능
                .build();
    }
}
```

application.yml 파일로 수정한다면 아래와 같음 (❓ 위랑 아래랑 우선순위는?)
```yml
routes:
- id: first-service
    uri: http://localhost:8081/
    predicates:
    - Path=/first-service/**
    filters:
    - AddRequestHeader=first-request, first-request-header
    - AddResponseHeader=first-response, first-response-header
```

### 커스텀 필터
❗커스텀 필터 사용시에는 FilterConfig를 Bean으로 주입하면 안됨.
```java
import org.springframework.http.server.reactive.ServerHttpRequest; //기존에 사용하던 ServletRequest과는 다른 개념
import org.springframework.http.server.reactive.ServerHttpResponse;
...

@Component
@Slf4j
public class CustomFilter extends AbstractGatewayFilterFactory<CustomFilter.Config> {
    public CustomFilter() {
        super(Config.class);
    }

    @Override
    public GatewayFilter apply(Config config) {
        // Custom Pre Filter
        return (exchange, chain) -> {
            ServerHttpRequest request = exchange.getRequest();
            ServerHttpResponse response = exchange.getResponse();

            log.info("Custom PRE filter: request id -> {}", request.getId());

            // Custom Post Filter
            return chain.filter(exchange).then(Mono.fromRunnable(()->{
                log.info("Custom POST filter: response code -> {}", response.getStatusCode()); // 비동기 처리해야하기 때문에 Mono 사용
            }));
        };
    }

    public static class Config {
        // Put the configuration properties
    }
}
```
만든 커스텀 필터 적용하기
```yml
routes:
- id: first-service
    uri: http://localhost:8081/
    predicates:
    - Path=/first-service/**
    filters:
        - CustomFilter
```